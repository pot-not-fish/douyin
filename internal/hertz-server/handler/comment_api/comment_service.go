// Code generated by hertz generator.

package comment_api

import (
	"context"
	"fmt"

	comment_api "douyin/internal/hertz-server/model/comment_api"
	"douyin/internal/hertz-server/model/user_api"
	"douyin/internal/pkg/dal/video_dal"
	"douyin/internal/pkg/kitex_client"
	"douyin/internal/pkg/mw"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"gorm.io/gorm"
)

// CommentAction .
// @router /douyin/comment/action [POST]
func CommentAction(ctx context.Context, c *app.RequestContext) {
	var err error
	var req comment_api.CommentActionReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(comment_api.CommentActionResp)

	row_user_id, ok := c.Get("user_id")
	if !ok {
		resp.StatusCode = 1
		resp.StatusMsg = "could not find user_id"
		c.JSON(consts.StatusOK, resp)
		return
	}
	user_id := row_user_id.(int64)

	switch req.ActionType {
	case 1:
		if req.CommentText == nil || *req.CommentText == "" {
			resp.StatusCode = 1
			resp.StatusMsg = "could not send empty comment"
			c.JSON(consts.StatusOK, resp)
			return
		}

		var comment = &video_dal.Comment{
			Content:    *req.CommentText,
			UserId:     user_id,
			VideoRefer: uint(req.VideoID),
		}

		if err := comment.CreateComment(); err != nil {
			resp.StatusCode = 1
			resp.StatusMsg = err.Error()
			c.JSON(consts.StatusOK, resp)
			return
		}

		userinfo, err := kitex_client.UserinfoRpc(ctx, []int64{user_id})
		if err != nil {
			resp.StatusCode = 1
			resp.StatusMsg = err.Error()
			c.JSON(consts.StatusOK, resp)
			return
		}

		create_date := fmt.Sprintf("%d-%d-%d %d:%d", comment.CreatedAt.Year(), comment.CreatedAt.Month(), comment.CreatedAt.Day(), comment.CreatedAt.Hour(), comment.CreatedAt.Minute())
		resp.Comment = &comment_api.Comment{
			ID: int64(comment.ID),
			User: &user_api.User{
				ID:              userinfo.User[0].UserId,
				Name:            userinfo.User[0].Name,
				FollowCount:     userinfo.User[0].FollowCount,
				FollowerCount:   userinfo.User[0].FollowerCount,
				IsFollow:        false, // 不能关注自己
				Avatar:          userinfo.User[0].Avatar,
				BackgroundImage: userinfo.User[0].Background,
				Signature:       userinfo.User[0].Signature,
				TotalFavorited:  userinfo.User[0].TotalFavorited,
				WorkCount:       userinfo.User[0].TotalFavorited,
				FavoriteCount:   userinfo.User[0].FavoriteCount,
			},
			Content:    *req.CommentText,
			CreateDate: create_date,
		}
		resp.StatusCode = 0
		resp.StatusMsg = "successfully publish comment"
	case 2:
		if req.CommentID == nil || *req.CommentID == 0 {
			resp.StatusCode = 1
			resp.StatusMsg = "empty comment id"
			c.JSON(consts.StatusOK, resp)
			return
		}

		var comment = &video_dal.Comment{
			UserId:     user_id,
			VideoRefer: uint(req.VideoID),
			Model:      gorm.Model{ID: uint(*req.CommentID)},
		}

		if err := comment.DeleteComment(); err != nil {
			resp.StatusCode = 1
			resp.StatusMsg = err.Error()
			c.JSON(consts.StatusOK, resp)
			return
		}

		resp.StatusCode = 0
		resp.StatusMsg = "successfully delete comment"
	default:
		resp.StatusCode = 1
		resp.StatusMsg = "Invalid action type"
	}

	c.JSON(consts.StatusOK, resp)
}

// CommentList .
// @router /douyin/comment/list [GET]
func CommentList(ctx context.Context, c *app.RequestContext) {
	var err error
	var req comment_api.CommentListReq
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	resp := new(comment_api.CommentListResp)

	comments, err := video_dal.RetrieveComment(req.VideoID)
	if err != nil {
		resp.StatusCode = 1
		resp.StatusMsg = err.Error()
		c.JSON(consts.StatusOK, resp)
		return
	}

	var user_id_list = make([]int64, 0, len(comments))
	for _, v := range comments {
		user_id_list = append(user_id_list, v.UserId)
	}

	if len(comments) == 0 { // 特判没有评论的情况
		resp.StatusCode = 0
		resp.StatusMsg = "OK"
		c.JSON(consts.StatusOK, resp)
		return
	}

	userinfo_list, err := kitex_client.UserinfoRpc(ctx, user_id_list)
	if err != nil {
		resp.StatusCode = 1
		resp.StatusMsg = err.Error()
		c.JSON(consts.StatusOK, resp)
		return
	}

	var isfollow_list = make([]bool, 0, len(comments))
	if req.Token == nil || *req.Token == "" { // nil对应不存在token字段，""对应token值为空
		for i := 0; i < len(comments); i++ {
			isfollow_list = append(isfollow_list, false)
		}
	} else {
		user_id, err := mw.TokenGetUserId(req.Token)
		if err != nil {
			resp.StatusCode = 1
			resp.StatusMsg = err.Error()
			c.JSON(consts.StatusOK, resp)
			return
		}

		var from_user_id_list = make([]int64, 0, len(comments))
		for i := 0; i < len(comments); i++ {
			from_user_id_list = append(from_user_id_list, user_id)
		}

		isfollow_list, err = kitex_client.IsFollowRpc(ctx, from_user_id_list, user_id_list)
		if err != nil {
			resp.StatusCode = 1
			resp.StatusMsg = err.Error()
			c.JSON(consts.StatusOK, resp)
			return
		}
	}

	for k, v := range comments {
		create_date := fmt.Sprintf("%d-%d-%d %d:%d", v.CreatedAt.Year(), v.CreatedAt.Month(), v.CreatedAt.Day(), v.CreatedAt.Hour(), v.CreatedAt.Minute())

		resp.CommentList = append(resp.CommentList, &comment_api.Comment{
			ID: int64(v.ID),
			User: &user_api.User{
				ID:              userinfo_list.User[k].UserId,
				Name:            userinfo_list.User[k].Name,
				FollowCount:     userinfo_list.User[k].FollowCount,
				FollowerCount:   userinfo_list.User[k].FollowerCount,
				IsFollow:        isfollow_list[k],
				Avatar:          userinfo_list.User[k].Avatar,
				BackgroundImage: userinfo_list.User[k].Background,
				Signature:       userinfo_list.User[k].Signature,
				TotalFavorited:  userinfo_list.User[k].TotalFavorited,
				WorkCount:       userinfo_list.User[k].WorkCount,
				FavoriteCount:   userinfo_list.User[k].FavoriteCount,
			},
			Content:    v.Content,
			CreateDate: create_date,
		})
	}

	resp.StatusCode = 0
	resp.StatusMsg = "OK"
	c.JSON(consts.StatusOK, resp)
}
